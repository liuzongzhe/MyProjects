Socket通信：

同步I/O，阻塞式通信
客户端：Socket
服务端：ServerSocket监听Socket
-----------------------------------------------------------------

同步I/O，非阻塞式通信
客户端：SocketChannel
服务端：ServerSocketChannel监听SocketChannel
-----------------------------------------------------------------

异步I/O，非阻塞式通信
客户端：AsynchronousSocketChannel
服务端：AsynchronousServerSocketChannel监听AsynchronousSocketChannel
-----------------------------------------------------------------

同步/异步：
（1）在任务调度者的角度看任务之间有无顺序关系，串行顺序操作（同步）、并行顺序操作（异步）；
（2）任务调度者发送的任务：指客户端发送的多个请求
（3）实现机制：多线程
（4）举例：打电话（同步）、发短信（异步）

阻塞/非阻塞：
（1）在CPU角度看内设(CPU和内存)和外设之间的速度匹配上差距产生的认识
	阻塞就是 CPU停下来等待一个慢操作(外设)完成 ，CPU才接着完成其它的事。
	非阻塞是在这个慢操作(外设)在执行时 ，CPU先去执行其他操作，等这个慢操作(外设)完成时，CPU再接着完成后续的操作。
（2）内设与外设的交互往往被抽象为IO，所以阻塞与非阻塞一般是针对IO来说的。
	阻塞式：当程序执行IO操作后，在这些操作返回之前，对应的线程会一致处于等待状态，直到有东西可读或者可写为止。
	非阻塞：如果没有东西可读，或者不可写，读写函数马上返回，而不会等待。
（3）接收任务调度者发送的任务：指服务器处理多个请求
（4）实现机制：
	阻塞式：等待被依赖任务完成
	非阻塞：基于观察者模式：Selector监听注册在上面的所有Channel(ServerSocketChannel和SocketChannel)，
		    只需要依赖者观察被依赖者任务完成情况，当被依赖者完成了任务后发送通知给依赖者就可以。
		    
-----------------------------------------------------------------
AIO用于文件处理还是比较快乐的，但用AIO来写网络消息处理服务器端与客户端是比较麻烦的事情，当然这只是我个人意见，主要是有几点原因：
一是AIO需要操作系统支持，还好Windows与Linux(模拟)都支持；
二是AIO同时使用递归调用和异步调用容易把程序员搞晕，代码容易出错；
三是CompletionHandler会使用单独的线程跑，容易出现多线程问题，频繁线程上下文切换比较消耗资源；
四是异步写要创建队列来缓存需要写入的数据，否则肯定会遇到WritePendingException。

相对来说，NIO比较清楚直白，容易控制。